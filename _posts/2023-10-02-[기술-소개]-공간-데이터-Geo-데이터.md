---
layout: post
date: 2023-10-02
title: "[기술 소개] 공간 데이터 Geo 데이터"
tags: [PostGIS, ]
categories: [지식한입, 아티클, ]
mermaid: true
---



### 1. 좌표계가 뭘까?

- [**좌표계에 대해 간단히 정리**](https://blog.tadadakcode.com/3)


#### 1.1. 대한민국 좌표 범위

- 우리나라는 동경 124도와 132_**도**_ 사이, 북위 33도와 43_**도**_ 사이

![0](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/0.png)


postgresql은 geometry 데이터를 다루기 위한 `PostGIS` 확장이 존재한다.


[bookmark](https://pamyferret.tistory.com/29)


Q) geometry를 왜 찾게 되었는가?


A) 이번에 지도를 다루는 사이드 프로젝트를 하게 되었는데 프로젝트를 수행하기 위해 선수 지식으로 학습을 진행했다.



### 2. 폴리곤 개념 이해하기



#### 2.1. 지도 데이터에서 폴리곤이란? 

- 좌표평면에 위도를 y축으로 경도를 x축으로 하여 가상의 사각형의 영역을 만드는 개념이다.


#### 2.2. 카카오 지도로 폴리곤 개념 이해하기


![1](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/1.png)

- [카카오 공식 문서](https://apis.map.kakao.com/web/sample/drawShape/)를 보게되면 아래와 같이 설명한다.
	- 사각형 영역의 남서쪽 좌표와 사각형 영역의 북동쪽 좌표를 통해 영역 계산
	- 이미지에 보이는 것처럼 좌표평면 1사 분면에


#### 2.3. Postgresql의 PostGIS를 사용해 폴리곤 만들기


Postgresql Geomatry 확장에서는 `ST_MakeEnvelope` 란 함수를 통해 폴리곤을 계산한다.


aws 공식문서에 이렇게 사용하라고 설명되어 있다. 

- [**ST_MakeEnvelope**](https://docs.aws.amazon.com/ko_kr/redshift/latest/dg/ST_MakeEnvelope-function.html)


{% raw %}
```sql
ST_MakeEnvelope(xmin,ymin,xmax,ymax)

ST_MakeEnvelope(xmin,ymin,xmax,ymax,srid)
```
{% endraw %}



_xmin_`DOUBLE PRECISION` 데이터 형식의 값입니다. 이 값은 상자의 왼쪽 아래 모서리의 첫 번째 좌표입니다.


_ymin_`DOUBLE PRECISION` 데이터 형식의 값입니다. 이 값은 상자의 왼쪽 아래 모서리의 두 번째 좌표입니다.


_xmax_`DOUBLE PRECISION` 데이터 형식의 값입니다. 이 값은 상자의 오른쪽 위 모서리의 첫 번째 좌표입니다.


_ymax_`DOUBLE PRECISION` 데이터 형식의 값입니다. 이 값은 상자의 오른쪽 위 모서리의 두 번째 좌표입니다.


_srid_공간 참조 시스템 식별자(SRID)를 나타내는 `INTEGER` 데이터 형식의 값입니다. 
SRID 값이 제공되지 않으면 0으로 설정됩니다.(즉, 좌표계이다)



### 3. Postgresql PostGIS 간단하게 실습하기



#### **3.1. 실습 데이터 생성 코드**

- 모든 좌표는 송파구 방이동 지역이다

SQL



{% raw %}
```sql
CREATE EXTENSION postgis;

-- DROP TABLE geo_data;

-- 공간 테이블 생성
CREATE TABLE geo_data (
    id SERIAL PRIMARY KEY,
    x decimal,
    y decimal,
    coordinates GEOMETRY(POINT, 4326)
);

INSERT INTO geo_data (x, y, coordinates)
VALUES
	(127.11193633701166, 37.512286015863836, ST_GeomFromText('POINT(127.11193633701166 37.512286015863836)', 4326)), 
	(127.1081706273, 37.511265984, ST_GeomFromText('POINT(127.1081706273 37.511265984)', 4326)), 
	(127.108469914672, 37.513772121875, ST_GeomFromText('POINT(127.108469914672 37.513772121875)', 4326)), 
	(127.1142603912, 37.5113359345, ST_GeomFromText('POINT(127.1142603912 37.5113359345)', 4326)), 
	(127.109331591402, 37.5133858780869, ST_GeomFromText('POINT(127.109331591402 37.5133858780869)', 4326)), 
	(127.10986974339507, 37.51298353110745, ST_GeomFromText('POINT(127.10986974339507 37.51298353110745)', 4326)), 
	(127.10901842428878, 37.51558641806041, ST_GeomFromText('POINT(127.10901842428878 37.51558641806041)', 4326)), 
	(127.111506834731, 37.5124933826657, ST_GeomFromText('POINT(127.111506834731 37.5124933826657)', 4326)), 
	(127.111321796903, 37.5093759932264, ST_GeomFromText('POINT(127.111321796903 37.5093759932264)', 4326)), 
	(127.107807565302, 37.5152047832206, ST_GeomFromText('POINT(127.107807565302 37.5152047832206)', 4326)), 
	(127.110594033479, 37.5107191730337, ST_GeomFromText('POINT(127.110594033479 37.5107191730337)', 4326)), 
	(127.10834742540638, 37.51463917990233, ST_GeomFromText('POINT(127.10834742540638 37.51463917990233)', 4326)), 
	(127.10881779657744, 37.51451981504001, ST_GeomFromText('POINT(127.10881779657744 37.51451981504001)', 4326)), 
	(127.108849541422, 37.5151935561479, ST_GeomFromText('POINT(127.108849541422 37.5151935561479)', 4326)), 
	(127.108325768862, 37.5142117636986, ST_GeomFromText('POINT(127.108325768862 37.5142117636986)', 4326)), 
	(127.109821400471, 37.515113998941, ST_GeomFromText('POINT(127.109821400471 37.515113998941)', 4326)), 
	(127.107812224531, 37.5071989079576, ST_GeomFromText('POINT(127.107812224531 37.5071989079576)', 4326)), 
	(127.11797580084, 37.5101663829521, ST_GeomFromText('POINT(127.11797580084 37.5101663829521)', 4326)), 
	(127.112401945538, 37.5120968134049, ST_GeomFromText('POINT(127.112401945538 37.5120968134049)', 4326)), 
	(127.109300061495, 37.5127068207763, ST_GeomFromText('POINT(127.109300061495 37.5127068207763)', 4326)), 
	(127.109223321372, 37.514223190787, ST_GeomFromText('POINT(127.109223321372 37.514223190787)', 4326)), 
	(127.108113610628, 37.5138460605328, ST_GeomFromText('POINT(127.108113610628 37.5138460605328)', 4326)), 
	(127.11479833054, 37.5139232758447, ST_GeomFromText('POINT(127.11479833054 37.5139232758447)', 4326))
  ;
 
SELECT COUNT(*) FROM geo_data; 
-- >>> 23
```
{% endraw %}




#### **3.2. 테이블 데이터 확인**



{% raw %}
```sql
SELECT * FROM geo_data;
```
{% endraw %}


- 결과

	![2](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/2.png)



#### **3.3. 폴리곤 만들기**



{% raw %}
```sql
SELECT ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326);

-- 결과: POLYGON ((127.10646933077587 37.51273616606448, 127.10646933077587 37.516466400555935, 127.11595361763263 37.516466400555935, 127.11595361763263 37.51273616606448, 127.10646933077587 37.51273616606448))
```
{% endraw %}


- 출력

	![3](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/3.png)


**[EWKT(Extended Well-Known Text) 표현으로 출력하기]**



{% raw %}
```sql
SELECT ST_AsEWKT(ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326));
-- 결과: SRID=4326;POLYGON((127.10646933077587 37.51273616606448,127.10646933077587 37.516466400555935,127.11595361763263 37.516466400555935,127.11595361763263 37.51273616606448,127.10646933077587 37.51273616606448))
```
{% endraw %}



결과


	![4](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/4.png)



#### 3.4. 폴리곤을 사용하여 row 조회하기


**[폴리곤에 포함된 row만 출력하기]**



{% raw %}
```sql
SELECT *
FROM geo_data
WHERE ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}


- 결과 보기

	![5](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/5.png)

- 결과 시각화: dbeaver에서 지원하는 기능이다

	![6](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/6.png)


**[폴리곤에 포함되지 않은 row만 출력하기]**



{% raw %}
```sql
SELECT *
FROM geo_data
WHERE NOT ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}


- 결과 보기

	![7](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/7.png)

- 결과 시각화: dbeaver에서 지원하는 기능이다

	![8](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/8.png)



#### 3.5. 폴리곤 결과와 카카오 지도 결과 비교


[**폴리곤과 함께 포함된 row만 출력하기]**



{% raw %}
```sql
SELECT 
	*,
	ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326)
FROM geo_data
WHERE ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}



결과 비교

- dbeaver로 확인: 총 **13개의 row가** 조회된다.

	![9](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/9.png)

- kakao 지도로 확인: **13개의 마커** 포함된다.

	![10](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/10.png)


**[폴리곤과 함께 포함되지 않은 row만 출력하기]**



{% raw %}
```sql
SELECT 
	*,
	ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326)
FROM geo_data
WHERE NOT ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}



결과 비교

- dbeaver로 확인: 총 **10개의 row가 조회**된다.

	![11](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/11.png)

- 카카오 지도로 확인: **10개의 마커가 미포함**된다.

	![12](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/12.png)


	![13](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/13.png)



### 4. `PostGIS` 함수와 일반적인 SQL 큰차이가 있을까 아니면 편의성일까?



#### 4.1. PostGIS의 공간 연산 함수 사용



{% raw %}
```sql
SELECT *
FROM geo_data
WHERE ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}


- 실행 계획


{% raw %}
```sql
EXPLAIN ANALYZE
SELECT *
FROM geo_data
WHERE ST_Contains(
    ST_MakeEnvelope(127.10646933077587, 37.51273616606448, 127.11595361763263, 37.516466400555935, 4326),
    coordinates
);
```
{% endraw %}



![14](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/14.png)



#### 4.2. 일반쿼리



{% raw %}
```sql
SELECT *
FROM geo_data
WHERE 1 = 1 
AND x BETWEEN 127.10646933077587 AND 127.11595361763263
AND y BETWEEN 37.51273616606448 AND 37.516466400555935
;
```
{% endraw %}


- 실행 계획


{% raw %}
```sql
EXPLAIN ANALYZE
SELECT *
FROM geo_data
WHERE 1 = 1 
AND x BETWEEN 127.10646933077587 AND 127.11595361763263
AND y BETWEEN 37.51273616606448 AND 37.516466400555935
;
```
{% endraw %}



![15](/assets/img/2023-10-02-기술-소개-공간-데이터-Geo-데이터.md/15.png)


코스트는 일반 쿼리가 더 적게 나온다.



#### 둘의 실행 결과를 사용해서 GPT 간단 답변



{% raw %}
```text
1번과 2번 쿼리는 서로 다른 방식으로 영역을 비교합니다. 
- 1번은 PostGIS의 공간 연산 함수를 사용하여 영역을 비교하고, 
- 2번은 일반적인 숫자 비교 연산자를 사용하여 x 및 y 좌표를 비교합니다.

성능상의 차이는 데이터의 양과 인덱스화 여부, 환경에 따라 다를 수 있습니다. 
여러 요인이 영향을 미치므로 정확한 성능 비교를 위해서는 데이터베이스의 특정 환경에서 직접 측정해보는 것이 중요합니다.

일반적으로 말하자면, PostGIS의 공간 연산 함수를 사용하는 것이 공간 데이터를 처리하는 데에 있어서 훨씬 더 효율적이고 정확합니다. 
PostGIS는 공간 인덱스를 활용하여 공간 연산을 최적화하므로 대부분의 경우에 빠르게 동작할 것입니다.
또한 1번 쿼리는 SRID(4326)을 명시적으로 사용하고 있습니다. 
이것은 데이터를 어떤 좌표 체계로 해석할지를 지정합니다. 
SRID가 올바르게 설정되어 있으면 정확한 결과를 얻을 수 있습니다.

하지만 2번 쿼리는 숫자 비교를 사용하고 있습니다. 이 경우에는 좌표 체계에 대한 고려가 없기 때문에 정확한 결과를 얻기 위해서는 좌표 값의 범위를 정확하게 파악해야 합니다.
종합적으로, PostGIS 함수를 사용하는 것이 공간 데이터를 다루는 데 더 적합하고 정확한 방법입니다. 
그러나 성능은 실제 환경에서의 데이터 양과 인덱스화 여부, 하드웨어 등에 따라 달라질 수 있습니다. 
따라서 성능 비교를 위해서는 실제 환경에서 측정해보는 것이 좋습니다.
```
{% endraw %}




#### (내가 이해한) 결론


우리 공간은 2차원 평면이 아니다. 일반 쿼리의 경우 단순 2차원 좌표의 거리를 계산한다.


반면 PostGIS는 3차원 공간에 대한 정보를 가지고, 거리를 측정한다. 


아주 극단적인 예를 들어보자


> A와 B의 거리는 1KM이다. 그리고  A와 B 사이에 높이 3KM의 산이 있다.


이러한 상황에서 A와 B를 이어주는 가장 효율적인 길을 찾는 요구사항이 있다.


단순 SQL로 거리를 측정하면, 직선상에 3KM 짜리 산이 있음에도 A와 B의 직선상의 거리를 가장 효율적이라고 나올 것이다. 이러한 오류를 없게 하기 위해 공간 데이터는 매우 중요하다. 


그리고 공간데이터는 개발뿐 아니라 여러 산업 분야에서 기본적으로 사용되는 기술이다.

